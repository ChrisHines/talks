Non-Orthogonal Choices in Go
20 Jan 2016

Chris Hines
chris@cs-guy.com
@chris_csguy



* Dimension

The minimum number of coordinates needed to describe a point in space.

- One dimension—a line—one coordinate; distance along the line.
- Two dimensions—a surface—two coordinates; (x, y) or (ϕ, ρ).
- Three dimensions—a volume—three coordinates; (x, y, z) or (length, width, depth).

* Orthogonality

- N orthogonal vectors describe an N-dimensional space.
- Orthogonal vectors are linearly independent—none of them can be built from a combination of the others.
- Basis vectors can be scaled and added to reach any point in the space they describe.

.html Coord_XY.svg

* Orthogonality in software

Software is more orthogonal when features or components are:

- Decoupled—changes in one don't affect the others.
- Minimal—their functionality does not overlap.
- Composable—they are easily combined in useful ways.

* Orthogonality in Go

In 2010 Rob Pike listed Go's principles as:

- Simple
- *Orthogonal*
- Succinct
- Safe

* Is Go orthogonal?

Rob Pike called out the following orthogonalities in Go:

- Constants (nearly) orthogonal to type system.
- Methods orthogonal to types.
- Interface types orthogonal to concrete types.
- Visibility orthogonal to type.
- Concurrency orthogonal to everything else.
- Functions orthogonal to variable location (easy closures, yay!).

* But are there exceptions?

* No!  —  Go doesn't have exceptions.

* panic("talk failed")

* recover()

* It turns out ... Go is not perfectly orthogonal.

* But no practical programming language is.

* Beware the Turing tarpit!

* Non-orthogonality creates choices

- Overlapping features allow more than one way to solve a problem.
- Not all choices are equally good.
- Choose the right tool for the problem.

* Three ways to count

.code counting/counting.go /^func forloop/,/^}/
.code counting/counting.go /^func gotoloop/,/^}/
.code counting/counting.go /^func recurse/,/^}/

* Counting three ways

.play counting/counting.go /^func main/,/^}/

* These are not hard choices

- Choosing a looping construct is tactical.
- The impact is almost always local to a function.

* More difficult choices

Dynamic behavior

- Interface values
- Function values

Concurrency control

- Channels
- import "sync"
- import "sync/atomic"

* These choices are strategic

- Often influence the public API, or
- Impact many functions in the package
- Or both

* Dynamic behavior

We have dynamic behavior when a function delegates some of its implementation details to other functions that are chosen at runtime.

Done well it helps reduce coupling.

It provides opportunities for extension and reuse.

Related concepts:

- Dynamic dispatch
- Polymorphism
- Inversion of control
- Strategy pattern

* Dynamic behavior with an interface value

.code dynamic_behavior/dynamic_behavior.go /^type StringDecoder interface/,/^}/+/^}/

* StringDecoder implementations

The [[https://golang.org/pkg/encoding/base32/#Encoding.DecodeString][encoding/base32]] and [[https://golang.org/pkg/encoding/base64/#Encoding.DecodeString][encoding/base64]] packages both have implementations of `StringDecoder`.

We can use the [[https://golang.org/pkg/encoding/hex/#DecodeString][encoding/hex.DecodeString]] function to satisfy the interface with an adapter type as follows.

.code dynamic_behavior/dynamic_behavior.go /^type StringDecoderFunc/,/^}/

* Using the implementations

.play dynamic_behavior/dynamic_behavior.go /^func main/,/^}/

* Dynamic behavior with a function value

.code dynamic_function/dynamic_function.go /^type StringDecoder/,/^}/

* StringDecoderFunc implementations

[[https://golang.org/pkg/encoding/hex/#DecodeString][encoding/hex.DecodeString]] matches the `StringDecoder` function type.

We can use _method_values_ to convert the [[https://golang.org/pkg/encoding/base32/#Encoding.DecodeString][encoding/base32]] and [[https://golang.org/pkg/encoding/base64/#Encoding.DecodeString][encoding/base64]] `DecodeString` methods to function values.

Finally, _function_literals_ allow us to pass a locally declared anonymous function.

* Using the functions

.play dynamic_function/dynamic_function.go /^func main/,/^}/

* Choices

Interfaces and function values both provide dynamic behavior.

Which should we use?

When?

* Differences

The differences between interface and function values inform our choice.

Interface values:

- Can have more than one method
- May have state stored in dynamic value
- Can be inspected for additional behaviors with type assertions
- Require an implementation declared elsewhere
- Require an adapter type to accept functions

Function values:

- Can have only one behavior
- May have state via a closure
- Can be declared inline with a function literal
- Accept functions and method values without boilerplate

* Informed choices

Use interface values when:

- More than one behavior required
- Typically stateful
- Implementations non-trivial

Use function values when:

- Only one behavior
- Typically stateless
- To enable inline implementations

* Case study

bufio.Scanner

# .play iface_poly/iface_poly.go /^func main/,/^func mustOpen/

* ioCopy(dst io.Writer, src io.Reader) (written int64, err error)

#.code iface_poly/iface_poly.go /^	buf :=/,/^	return/

* ioCopy(dst io.Writer, src io.Reader) (written int64, err error)

An optimization

#.code iface_poly/iface_poly.go /^	// If the reader/,/^	}/

* Function types